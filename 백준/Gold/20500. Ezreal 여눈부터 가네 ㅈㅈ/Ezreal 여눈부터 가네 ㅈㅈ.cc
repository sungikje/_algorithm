#include <iostream>
#include <vector>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n;
    std::cin >> n;
    std::vector<std::vector<long long>> dp(n+1, std::vector<long long>(3,0));

    dp[0][0] = 1;
    for(int i = 0; i < n; i++) {
        for(int r = 0; r < 3; r++) {
            dp[i+1][(r+1)%3] = (dp[i+1][(r+1)%3] + dp[i][r]) % 1000000007;
            dp[i+1][(r+5)%3] = (dp[i+1][(r+5)%3] + dp[i][r]) % 1000000007;
        }
    }
    std::cout << dp[n-1][1];
}

/*
조건 0 - 1515자리
    직접 수를 저장할 수 없다.
조건 1 - 15의 배수
    3 * 5 구조로 아래 조건을 만족해야 한다.
        1. 3의 배수 조건: 전체 요소의 합이 "3의 배수"여야 한다.
        2. 5의 배수 조건: 맨 마지막 요소가 "0 또는 5"로 끝나야 한다.
조건 2 - 1과 5로만 구성
    나머지를 상태 변화를 추적할 때 dp에 적용되는 연산은 +1, +5(or +2(5%3))로만 진행된다.
    조건 2에 위의 조건 1-2를 더해 5로만 끝나야되는 것을 알 수 있다.

로직
    3의 배수를 만족하기 위해서 %3을 진행하기에 나머지는 0, 1, 2만 가능하다.
    자릿수를 n까지 늘려가며 수의 구성은 1, 5로만 가능하기에 1, 5를 추가해 자릿수를 늘리고 나머지 상태 변화를 추적한다.
    - dp[자릿수][나머지]: 
        - 기저 상태: 아무 것도 안한 경우 = 1가지로 dp[0][0] = 1(하나의 경우)로 시작한다.
        아무것도 안 만든 상태도 하나의 유효한 시작점으로 둬야 전이가 가능하다.

    맨 마지막 요소는 5로 고정이기에 n-1 자릿수를 출력하며 마지막 자리가 5가 들어오고 3의 배수를 만족하기 위해선 나머지가 1이 존재하는 수에 5를 붙여야 한다.
    5를 붙이는 경우 5%3=2이기 때문에 나머지가 1인 상태에 붙여야 3의 배수가 된다.
*/